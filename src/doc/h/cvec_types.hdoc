// clang-format off
//alloc_fn_t
/**
 * @typedef alloc_fn_t
 * @brief Allocate raw storage.
 *
 * @param size  Number of bytes to allocate. May be zero; the behavior
 *              must match the platform’s `malloc(0)` semantics.
 * @return On success, returns a valid pointer to at least `size` bytes
 *         suitably aligned for any object type; on failure, returns `NULL`
 *
 * @note Returned memory is uninitialized.
 * @note Alignment must satisfy the needs of elements with size `memb_size`.
 */

//realloc_fn_t
/**
 * @typedef realloc_fn_t
 * @brief Resize or move an existing allocation.
 *
 * @param ptr   A pointer previously returned by this allocator family,
 *              or NULL to behave like `alloc(size)`.
 * @param size  New size in bytes. If 0, behavior matches your allocator
 *              family’s `realloc(p,0)` semantics (often frees and may
 *              return NULL). The vector never depends on a non-NULL
 *              return when `size==0`.
 * @return On success, a pointer to a block at least `size` bytes long
 *         (possibly moved). On failure, returns `NULL` and leaves the
 *         original block valid and unmodified.
 *
 * @warning Must be the *same family* as `alloc_fn_t` and `free_fn_t`.
 */

//free_fn_t
/**
 * @typedef free_fn_t
 * @brief Release storage obtained from this allocator family.
 *
 * @param ptr   Pointer returned by the family’s `alloc`/`realloc`, or `NULL`
 *              (which must be a no-op).
 */

//memcpy_fn_t
/**
 * @typedef memcpy_fn_t
 * @brief Copy `n` bytes from `src` to `dst` (non-overlapping).
 *
 * @param dst   Destination pointer (restrict-qualified).
 * @param src   Source pointer (restrict-qualified).
 * @param n     Number of bytes to copy.
 * @return      The original value of `dst`.
 *
 * @note If `NULL` in `cvec_hooks_t`, the library falls back to the platform
 *       `memcpy`. Overlapping ranges are undefined; use `memmove` instead.
 * @note The `restrict` qualifiers advertise non-overlap to enable
 *       optimized implementations.
 */

//grow_fn_t
/**
 * @typedef grow_fn_t
 * @brief Determine a new capacity (in elements) for a vector grow.
 *
 * @param old_nmemb  Current capacity (in elements). May be `0`.
 * @param new_nmemb  Minimum required capacity (in elements). The result
 *                   must be >= `new_nmemb`.
 * @param memb_size  Element size in bytes; supplied for overflow checks.
 * @return A chosen capacity (in elements), >= `new_nmemb`. On overflow
 *         or refusal to grow, implementations may return `0` to signal
 *         “cannot grow” (the caller will treat it as failure).
 *
 * @par requirements
 *  - Monotonic: result >= new_nmemb.
 *  - Progress: for new_nmemb > old_nmemb, result should typically be
 *    > old_nmemb to avoid O(n^2) reallocation patterns.
 *  - Overflow-safe: do not choose a capacity that would overflow
 *    `result * memb_size` in `size_t`.
 *
 * @par examples
 *  - Doubling: `max(new_nmemb, max<size_t>(16, old_nmemb*2))`
 *  - 1.5×: `old + old/2 + k`, clamped to `new_nmemb`
 *  - Exact: `new_nmemb` (minimal, more reallocs)
 */

//cvec_hooks_t
/**
 * @struct cvec_hooks_t
 * @brief Customization points for allocation, copying, and growth policy.
 *
 * Populate this struct to override default behaviors. It is valid to
 * provide a partial override: set any members you want to customize and
 * leave others NULL; the library will fill NULL members with defaults.
 *
 * @var cvec_hooks_t::alloc
 *   Allocation function. Required to pair with `realloc`/`free` of the
 *   same family if any growth or deallocation occurs.
 *
 * @var cvec_hooks_t::realloc
 *   Reallocation function. Must be compatible with `alloc`/`free`.
 *
 * @var cvec_hooks_t::free
 *   Deallocation function for memory from this family.
 *
 * @var cvec_hooks_t::memcpy
 *   Optional memcpy replacement. If NULL, falls back to `memcpy`.
 *
 * @var cvec_hooks_t::grow
 *   Optional capacity growth policy. If NULL, a library default (e.g.,
 *   1.5× with a small floor) is used.
 */

//cvec_t
/**
 * @struct cvec_t
 * @brief Contiguous, growable array (vector) with pluggable allocation hooks.
 *
 * A `cvec_t` manages a contiguous element buffer whose capacity grows on
 * demand. The struct itself does not own any resources until an operation
 * that requires storage (e.g., `cvec_reserve`, `cvec_push`) is performed.
 * Initialization is O(1) and allocation-free.
 *
 * ### Layout & invariants
 * - `data == NULL`  <=>  `nmemb_cap == 0` and `nmemb == 0`.
 * - `0 <= nmemb <= nmemb_cap`.
 * - `memb_size > 0` after successful `cvec_init()`.
 * - When `data != NULL`, it points to at least `nmemb_cap * memb_size` bytes,
 *   aligned suitably for elements of size `memb_size`.
 *
 * ### Ownership & lifetime
 * - The vector *owns* the allocation referenced by `data` and releases it via
 *   `hooks.free` (or the default) in `cvec_free()`.
 * - The `hooks` table is stored **by value** inside the vector; callers may pass
 *   a partially filled table to `cvec_init()`, and any NULL members are set to
 *   defaults (see `cvec_hooks_init()`).
 * - Copying a `cvec_t` with a plain struct assignment *does not* duplicate the
 *   allocation; it creates two structs pointing at the same `data`, which is
 *   a use-after-free hazard. Provide and use explicit `cvec_clone()` / `cvec_move()`
 *   helpers if you need deep copy or ownership transfer semantics.
 *
 * ### Error reporting
 * - `error` records all error conditions encountered by vector operations see `enum cvec_error_t`.
 *   Functions also return status codes; `error` is a convenience for post-mortem inspection.
 *
 * ### Thread-safety
 * - A `cvec_t` has no internal synchronization. Concurrent access from multiple
 *   threads requires external coordination. Reading and writing the same instance
 *   without synchronization is undefined behavior.
 *
 * @var cvec_t::data
 *   Pointer to the element buffer, or `NULL` when the vector has no storage.
 *   When non-NULL, the buffer contains `nmemb` initialized elements in the
 *   leading region and spare capacity up to `nmemb_cap`.
 *
 * @var cvec_t::nmemb_cap
 *   Capacity (in elements) of `data`. Always >= `nmemb`. Zero when `data == NULL`.
 *
 * @var cvec_t::nmemb
 *   Current number of elements considered in-use. `0 <= nmemb <= nmemb_cap`.
 *
 * @var cvec_t::memb_size
 *   Size, in bytes, of a single element. Fixed for the lifetime of the vector.
 *   Set by `cvec_init()`. Must be non-zero.
 *
 * @var cvec_t::error
 *   Sticky error flags for all failing operations. Set to
 *   `ECVEC_NONE` by `cvec_init()` and cleared by successful operations that
 *   explicitly document doing so.
 *
 * @var cvec_t::hooks
 *   Function table controlling allocation (`alloc`, `realloc`, `free`),
 *   copying (`memcpy`), and growth policy (`grow`). Stored by value and
 *   finalized at `cvec_init()` via `cvec_hooks_init()` to fill any NULL
 *   members with defaults. The `alloc`/`realloc`/`free` members must be from
 *   the same allocator family. See `struct cvec_hooks_t`.
 *
 * ### Typical usage
 * @code
 * cvec_t v;
 * cvec_hooks_t h = {0};          // partial override allowed
 * cvec_hooks_init(&h);           // fill defaults
 * cvec_init(&v, sizeof(int), &h);
 *
 * int x = 42;
 * cvec_push(&v, &x);             // allocates on first grow
 * // ...
 * cvec_free(&v);                 // releases owned storage
 * @endcode
 *
 * ### Notes
 * - Capacity growth honors `hooks.grow` if provided; otherwise a library
 *   default (e.g., ~1.5× with a small floor) is used.
 * - Implementations must guard `nmemb_cap * memb_size` against `size_t`
 *   overflow before allocating.
 * - If you need allocator switching at runtime, provide a dedicated API
 *   that migrates existing storage safely (never `realloc` across allocators).
 */